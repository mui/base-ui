# Select

<Subtitle>A common form component for choosing a predefined value in a dropdown menu.</Subtitle>
<Meta
  name="description"
  content="A high-quality, unstyled React select component that allows you for choosing a predefined value in a dropdown menu."
/>

<Demo path="./demos/hero" />

## Usage guidelines

- **Prefer Combobox for large lists**: Select is not filterable, aside from basic keyboard typeahead functionality to find items by focusing and highlighting them. Prefer [Combobox](/react/components/combobox) instead of Select when the number of items is sufficiently large to warrant filtering.

## Anatomy

Import the component and assemble its parts:

```jsx title="Anatomy"
import { Select } from '@base-ui-components/react/select';

<Select.Root>
  <Select.Trigger>
    <Select.Value />
    <Select.Icon />
  </Select.Trigger>

  <Select.Portal>
    <Select.Backdrop />
    <Select.Positioner>
      <Select.ScrollUpArrow />
      <Select.Popup>
        <Select.Arrow />
        <Select.Item>
          <Select.ItemText />
          <Select.ItemIndicator />
        </Select.Item>
        <Select.Separator />
        <Select.Group>
          <Select.GroupLabel />
        </Select.Group>
      </Select.Popup>
      <Select.ScrollDownArrow />
    </Select.Positioner>
  </Select.Portal>
</Select.Root>;
```

## API reference

<Reference
  component="Select"
  parts="Root, Trigger, Value, Icon, Backdrop, Portal, Positioner, Popup, Arrow, Item, ItemText, ItemIndicator, Group, GroupLabel, ScrollUpArrow, ScrollDownArrow, Separator"
/>

## Formatting the value

By default, the `Select.Value` component renders the raw `value`.

Passing the `items` prop to `Select.Root` instead renders the matching label for the rendered value:

```jsx title="items prop (Array)" "items"1,3
const items = [
  { value: null, label: 'Select theme' },
  { value: 'system', label: 'System default' },
  { value: 'light', label: 'Light' },
  { value: 'dark', label: 'Dark' },
];

<Select.Root items={items}>
  <Select.Value />
</Select.Root>;
```

```jsx title="items prop (Record)" "items"1,3
const items = {
  null: 'Select theme',
  system: 'System default',
  light: 'Light',
  dark: 'Dark',
};

<Select.Root items={items}>
  <Select.Value />
</Select.Root>;
```

A function can also be passed as the `children` prop of `Select.Value` to render a formatted value:

```jsx title="Lookup map" {8-12}
const items = {
  monospace: 'Monospace',
  serif: 'Serif',
  'san-serif': 'Sans-serif',
};

<Select.Value>
  {(value: keyof typeof items) => (
    <span style={{ fontFamily: value }}>
      {items[value]}
    </span>
  )}
</Select.Value>;
```

## Positioning

`Select.Positioner` by default has a special prop called `alignItemWithTrigger`, which causes the positioning to act differently from other `Positioner` components.
This prop makes the select menu overlap the trigger so the selected item's text is nicely aligned with the trigger's value text.

To make the select menu not overlap the trigger, set the `alignItemWithTrigger` prop to `false`.
When set to `true` (its default) there are a few important side effects to note:

- **Interaction type dependent**: The `alignItemWithTrigger`positioning mode is only active if `mouse` or `keyboard` was the input modality used to open the menu. It does not apply for `touch` or `pen` input.
- **Viewport space dependent**: There must be enough space in the viewport to align the selected item's text with the trigger's value text without causing the menu to be too vertically small - otherwise, it falls back to the default positioning mode. This can be customized by setting `min-height` on the `Select.Positioner` element; a smaller value will fallback less often. Additionally, the trigger must be at least 20px from the edges of the top and bottom of the viewport, or it will also fall back.
- **Other positioning props are ignored**: Props like `side` or `align` have no effect unless the prop is set to `false` or when in fallback mode.

## Examples

### Multiple selection

Add the `multiple` prop to the `Select.Root` component to allow multiple selections.

<Demo path="./demos/multiple" compact />
