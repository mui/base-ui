#!/usr/bin/env node
/* eslint-disable no-await-in-loop */
/* eslint-disable no-console */

import fs from 'fs/promises';
import path from 'path';
import glob from 'fast-glob';
import * as prettier from 'prettier';
import { unified } from 'unified';
import remarkParse from 'remark-parse';
import remarkGfm from 'remark-gfm';
import remarkStringify from 'remark-stringify';
import { visit } from 'unist-util-visit';
import { mdxToMarkdown } from './mdxToMarkdown.mjs';
import { resolveUrl, isAbsoluteUrl } from './resolver.mjs';

const PROJECT_ROOT = path.resolve(import.meta.dirname, '../..');
const MDX_SOURCE_DIR = path.join(PROJECT_ROOT, 'src/app/(public)/(content)/react');
const OUTPUT_BASE_DIR = path.join(PROJECT_ROOT, 'public');
const OUTPUT_REACT_DIR = path.join(OUTPUT_BASE_DIR, 'react');

// Use the deployment URL if available, just root relative otherwise
const BASE_URL = process.env.DEPLOY_PRIME_URL || '/';

/**
 * Remark plugin to increment heading levels by a specified amount
 * @param {number} increment - Amount to increment each heading level
 */
function incrementHeaders(increment = 1) {
  return (tree) => {
    visit(tree, 'heading', (node) => {
      node.depth = Math.min(node.depth + increment, 6); // Cap at h6
    });
  };
}

function githubSlugify(text) {
  return text
    .trim()
    .toLowerCase()
    .replace(/[^\w\s-]/g, '') // remove punctuation except - and space
    .replace(/\s+/g, '-') // spaces to hyphens
    .replace(/-+/g, '-') // collapse multiple hyphens
    .replace(/^-+|-+$/g, ''); // trim leading/trailing hyphens
}

function resolveRelativeLinks({ base, metadataByUrl = new Map() }) {
  return (tree) => {
    visit(tree, 'link', (node) => {
      if (!node.url || isAbsoluteUrl(node.url)) {
        return;
      }

      const urlPath = node.url.endsWith('.md') ? node.url.slice(0, -3) : node.url;
      const metadata = metadataByUrl.get(urlPath);

      if (metadata) {
        const hash = githubSlugify(metadata.title);
        node.url = `#${hash}`;
      } else {
        node.url = resolveUrl(node.url, base);
      }
    });
  };
}

/**
 * Function to process markdown and increment headers
 * @param {string} markdown - Markdown string to process
 * @param {number} increment - Amount to increment headers by
 * @returns {Promise<string>} - Processed markdown
 */
async function prepareForInlineMarkdown(markdown, increment, metadataByUrl) {
  const result = await unified()
    .use(remarkParse)
    .use(remarkGfm)
    .use(incrementHeaders, increment)
    .use(resolveRelativeLinks, { base: BASE_URL, metadataByUrl })
    .use(remarkStringify)
    .process(markdown);
  return String(result.value);
}

/**
 * Generate llms.txt and markdown files from MDX content
 */
async function generateLlmsTxt() {
  console.log('Generating llms.txt and markdown files...');

  try {
    // Create output directories if they don't exist
    await fs.mkdir(OUTPUT_BASE_DIR, { recursive: true });
    await fs.mkdir(OUTPUT_REACT_DIR, { recursive: true });

    const metadataByUrl = new Map();
    // Store metadata for each section as objects indexed by ID
    const metadataBySection = {
      overview: {},
      handbook: {},
      components: {},
      utils: {},
    };

    // Counter for total files processed
    let totalFiles = 0;

    const mdxFiles = await glob('**/*/page.mdx', {
      cwd: MDX_SOURCE_DIR,
      absolute: true,
    });

    const mdxFilesInfo = mdxFiles.map((mdxFile) => {
      const relativePath = path.relative(MDX_SOURCE_DIR, mdxFile);
      const dirPath = path.dirname(relativePath);
      const urlPath = `/${path.join('react', dirPath).replace(/\\/g, '/')}`;
      const outputFilePath = path.join(OUTPUT_REACT_DIR, `${dirPath}.md`);
      return { urlPath, mdxFile, outputFilePath };
    });

    const urlsWithMdVersion = new Set(mdxFilesInfo.map((info) => info.urlPath));

    // Process files from a specific section
    const processSection = async (sectionName) => {
      console.log(`Processing ${sectionName} section...`);

      for (const { urlPath, mdxFile, outputFilePath } of mdxFilesInfo) {
        if (!urlPath.startsWith(`/react/${sectionName}/`)) {
          continue;
        }

        const mdxContent = await fs.readFile(mdxFile, 'utf-8');

        const { markdown, title, subtitle, description } = await mdxToMarkdown(
          mdxContent,
          mdxFile,
          { urlPath, urlsWithMdVersion },
        );

        // Create directories for output if needed
        await fs.mkdir(path.dirname(outputFilePath), { recursive: true });

        const frontmatter = [
          '---',
          `title: ${title || 'Untitled'}`,
          subtitle ? `subtitle: ${subtitle}` : null,
          description ? `description: ${description}` : null,
          '---',
        ]
          .filter(Boolean)
          .join('\n');

        // Create markdown content with frontmatter
        let content = [frontmatter, '', markdown].join('\n');

        // Format markdown with frontmatter using prettier
        const prettierOptions = await prettier.resolveConfig(outputFilePath);

        content = await prettier.format(content, {
          ...prettierOptions,
          filepath: outputFilePath,
          parser: 'markdown',
        });

        // Write formatted markdown file
        await fs.writeFile(outputFilePath, content, 'utf-8');

        // Extract the filename without extension to use as id
        const fileId = path.basename(outputFilePath, '.md');

        const pageMeta = {
          id: fileId,
          title: title || 'Untitled',
          subtitle: subtitle || '',
          description: description || '',
          urlPath,
          mdUrlPath: `${urlPath}.md`,
          fullMarkdown: markdown,
        };

        // Store metadata for this file in the appropriate section
        metadataBySection[sectionName][fileId] = pageMeta;
        metadataByUrl.set(urlPath, pageMeta);

        // Increment the counter
        totalFiles += 1;

        console.log(`Processed: ${mdxFile}`);
      }
    };

    // Process each section
    await processSection('overview');
    await processSection('handbook');
    await processSection('components');
    await processSection('utils');

    // Build shared preamble for both files
    const preamble = [
      '# Base UI',
      '',
      'This is the documentation for the `@base-ui-components/react` package.',
      'It contains a collection of components and utilities for building user interfaces in React.',
      'The library is designed to be composable and styling agnostic.',
      '',
    ];

    // Page rendering functions - focused only on their unique logic
    const renderPageAsLink = (page) => {
      const resolvedUrl = resolveUrl(page.mdUrlPath, BASE_URL);
      return [`- [${page.title}](${resolvedUrl}): ${page.description}`];
    };
    const renderPageAsInline = async (page) => {
      const content = await prepareForInlineMarkdown(page.fullMarkdown, 2, metadataByUrl);
      return [content];
    };

    // Define specific orders for sections
    const overviewOrder = ['quick-start', 'accessibility', 'releases', 'about'];
    const handbookOrder = ['styling', 'animation', 'composition'];
    const componentsOrder = Object.keys(metadataBySection.components).sort();
    const utilsOrder = Object.keys(metadataBySection.utils).sort();

    // Helper function to map ordered IDs to their metadata objects
    const mapOrderToMetadata = (orderArray, metadataObject) => {
      const metadataList = Object.values(metadataObject);
      const orderMap = new Map(orderArray.map((id, index) => [id, index]));
      return metadataList.sort((a, b) => {
        return (orderMap.get(a.id) ?? Infinity) - (orderMap.get(b.id) ?? Infinity);
      });
    };

    // Create the file structure with all sections and pages in correct order
    const structure = {
      sections: [
        {
          title: 'Overview',
          pages: mapOrderToMetadata(overviewOrder, metadataBySection.overview),
        },
        {
          title: 'Handbook',
          pages: mapOrderToMetadata(handbookOrder, metadataBySection.handbook),
        },
        {
          title: 'Components',
          pages: mapOrderToMetadata(componentsOrder, metadataBySection.components),
        },
        {
          title: 'Utilities',
          pages: mapOrderToMetadata(utilsOrder, metadataBySection.utils),
        },
      ],
    };

    const createFile = async (filename, pageRenderer) => {
      // Generate sections with shared logic
      const sections = [];

      for (const section of structure.sections) {
        if (section.pages.length === 0) {
          continue;
        }

        const sectionContent = [`## ${section.title}`, ''];

        // Use the page renderer for each page (handle async renderers)
        for (const page of section.pages) {
          const renderedPage = await pageRenderer(page);
          sectionContent.push(...renderedPage);
        }

        sectionContent.push(''); // Add empty line after section
        sections.push(...sectionContent);
      }

      let content = [...preamble, ...sections].join('\n');

      // Apply prettier formatting
      const filePath = path.join(OUTPUT_BASE_DIR, filename);
      const prettierOptions = await prettier.resolveConfig(filePath);

      content = await prettier.format(content, {
        ...prettierOptions,
        filepath: filePath,
        parser: 'markdown',
      });

      await fs.writeFile(filePath, content, 'utf-8');
    };

    // Generate both files in parallel
    await Promise.all([
      createFile('llms.txt', renderPageAsLink),
      createFile('llms-full.txt', renderPageAsInline),
    ]);

    console.log(`Successfully generated ${totalFiles} markdown files, llms.txt, and llms-full.txt`);
  } catch (error) {
    console.error('Error generating llms.txt:', error);
    process.exit(1);
  }
}

// Run the generator
generateLlmsTxt();
